#' Interpolate USCRN station data to grid points within the contiguous USA
#'
#' Create a matrix containing predictions generated by a GpGp interpolation on
#' grid points at \code{resolution} based on a formula \code{formula}. Because
#' of GpGp limitations, the minimum number of rows in \code{data} is 31.
#'
#' The formula should be in the format \code{value ~ LONGITUDE + LATITUDE + ...},
#' where \code{value} is the column of values to be interpolated over,
#' \code{LONGITUDE} and \code{LATITUDE} are the corresponding coordinates for
#' each value, and \code{...} are additional columns for covariates.
#'
#' If covariates are included, \code{X_pred} should be provided, containing a
#' design matrix to be passed to [GpGp::predictions()]. The matrix should be
#' in the same order as the formula.
#'
#' See [rustcrn::grid_points_usa()], [GpGp::predictions()] for more information
#' on how the grid and interpolation is generated.
#'
#' @param formula an object of class [stats::formula()], in the format \code{value ~ LONGITUDE + LATITUDE + ...}
#' @param data an optional data frame containing the variables in the model.
#' @param X_pred an optional design matrix of covariates for predictions, to be passed to [GpGp::predictions()].
#' @param resolution numeric value for grid resolution, to be passed to [rustcrn::grid_points_usa()].
#'
#' @return A data frame of predictions corresponding longitude and latitude
#' \itemize{
#' \item \code{long} Longitude in decimal degrees
#' \item \code{lat} Latitude in decimal degrees
#' \item \code{in_usa} numeric 1 if the point is in the contiguous USA, 0 otherwise
#' \item \code{prediction} predicted values at \code{(long, lat)} based on GpGp interpolation
#' }
#' @export
#'
#' @examples
#' # Interpolation of every other station at resolution of 50
#' other <- rustcrn::stations[seq(2, nrow(rustcrn::stations), by = 2),]
#' value_other <- temp_trend(other$WBANNO)[,2]
#' int_other <- interpolation( value_other ~ LONGITUDE + LATITUDE, data = other,
#'                             resolution = 50 )
interpolation <- function(formula, data, X_pred = NULL, resolution = 100){
  #get rid of Hawaii and alaska from Data (longitudee less than -125)
  data <- data[data[[3]] > -125, ]
  data <- data[data[[3]] < 0, ]
  
  # read formula
  mi <- match.call()
  mi <- mi[c(1, match(c("formula", "data"), table = names(mi), nomatch = 0))]
  mi$drop.unused.levels <- TRUE
  mi[[1]] <- quote(stats::model.frame)
  mi <- eval(expr = mi, envir = parent.frame())

  y <- as.matrix(mi[,1])
  locs <- mi[,2:3]
  if(ncol(mi) > 3) X <- cbind(1,as.matrix(mi[,4:ncol(mi)]))
  else X <- NULL

  #Fit a model using formula, including optional covariates
  fit <- GpGp::fit_model(y = y,
                         locs = locs,
                         X = X,
                         covfun_name = "matern_sphere",
                         silent = TRUE)

  #Create grid with personalize resolution
  grid_square <- grid_points_usa(resolution)

  #Prepare all gradients
  locs_pred <- cbind(grid_square$long, grid_square$lat)

  if(is.null(X_pred)) X_pred <- stats::model.matrix(~1, data = grid_square)

  #Create prediction
  prediction <- GpGp::predictions(fit = fit,
                                  locs_pred = locs_pred,
                                  X_pred = X_pred)

  #Make a data frame of prediction with its corresponding longitude and latitude
  result <- cbind(grid_square, prediction )

  return(result)
}
