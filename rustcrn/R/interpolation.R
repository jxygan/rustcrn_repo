#' Interpolate USCRN station data to grid points within the contiguous USA
#'
#' Create a matrix containing predictions generated by a GpGp interpolation on
#' grid points at \code{resolution}. By default, \code{value} accepts
#' non-NA values corresponding to stations in the same order as in [rustcrn::stations],
#' but stations can be subsetted by providing a vector of WBANNOs. Because of
#' GpGp limitations, the minimum number of values is 31.
#'
#' See [rustcrn::grid_points_usa], [GpGp::predictions] for more information
#' on how the grid and interpolation is generated.
#'
#' @param value a vector of data corresponding to stations specified in \code{stations}
#' @param stations an optional numeric vector of station WBANNOs to use in interpolation
#' @param resolution numeric value for grid resolution
#'
#' @return A data frame of predictions corresponding longitude and latitude
#' \itemize{
#' \item \code{long} Longitude in decimal degrees
#' \item \code{lat} Latitude in decimal degrees
#' \item \code{in_usa} numeric 1 if the point is in the contiguous USA, 0 otherwise
#' \item \code{prediction} predicted values at \code{(long, lat)} based on GpGp interpolation
#' }
#' @export
#'
#' @examples
#' # To get data frame of predicted estimated trend of temperature of USA with
#' # resolution 100
#' tt_all <- temp_trend(rustcrn::stations$WBANNO)
#' value  <- tt_all[, 2]
#' int_all <- interpolation( value )
#'
#' # Interpolation of every other station at a lower resolution
#' other <- rustcrn::stations$WBANNO[seq(2, nrow(rustcrn::stations), by = 2)]
#' value_other <- temp_trend(other)[,2]
#' int_other <- interpolation( value_other, stations = other, resolution = 75 )
interpolation <- function(value, stations = NULL, resolution = 100){
  # Choose locations
  if(is.null(stations)){
    locs <- cbind(rustcrn::stations$LONGITUDE, rustcrn::stations$LATITUDE)
  }
  else {
    indices <- match(stations, rustcrn::stations$WBANNO)
    locs <- cbind(rustcrn::stations[indices,"LONGITUDE"],
                  rustcrn::stations[indices,"LATITUDE"])
  }

  #Fit a model using value provided and station location
  y <- value
  fit <- GpGp::fit_model(y = y,
                         locs = locs,
                         covfun_name = "matern_sphere",
                         silent = TRUE)

  #Create grid with personalize resolution
  grid_square <- grid_points_usa(resolution)

  #Prepare all gradients
  locs_pred <- cbind(grid_square$long, grid_square$lat)

  #Create prediction
  x <- stats::model.matrix( ~1, data = grid_square )
  prediction <- GpGp::predictions(fit = fit,
                                  locs_pred = locs_pred,
                                  X_pred = x)

  #Make a data frame of prediction with its corresponding longitude and latitude
  result <- cbind(grid_square, prediction )

  return(result)
}
